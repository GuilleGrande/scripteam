# Story 1.2 Remediation Guide
**Critical Issues Resolution for Expo + React Native Web Migration**

*Generated by Quinn (Test Architect) - 2025-09-21*

## Executive Summary

Story 1.2 currently has **FAIL** gate status due to 2 high-severity and 2 medium-severity issues blocking production readiness. This guide provides step-by-step remediation instructions for the development team.

**Quality Score: 60/100 → Target: 85+**

## Critical Issues (MUST FIX)

### BUILD-001: Expo Build Configuration Failure ⚠️ HIGH SEVERITY

**Problem**: `expo export:web` fails with Metro bundler configuration errors

**Root Cause**: Package.json scripts use outdated Expo commands incompatible with current SDK 54.0.9

**Solution**:

1. **Update apps/mobile/package.json scripts**:
   ```json
   {
     "scripts": {
       "start": "expo start",
       "android": "expo start --android",
       "ios": "expo start --ios",
       "web": "expo start --web",
       "build:web": "expo export --platform web",
       "build:production": "expo export --platform web --minify",
       "dev": "expo start --web --dev-client"
     }
   }
   ```

2. **Verify Metro configuration** in `metro.config.js`:
   ```javascript
   const { getDefaultConfig } = require('expo/metro-config');

   const config = getDefaultConfig(__dirname);

   // Add web support
   config.resolver.platforms = ['ios', 'android', 'native', 'web'];

   module.exports = config;
   ```

3. **Test build process**:
   ```bash
   cd apps/mobile
   npm run build:web
   # Should complete without Metro bundler errors
   ```

**Validation Criteria**:
- [ ] `npm run build:web` completes successfully
- [ ] Generated web bundle loads in browser
- [ ] No Metro configuration warnings in console

---

### TEST-001: Zero Test Coverage ⚠️ HIGH SEVERITY

**Problem**: No unit tests, integration tests, or regression tests for migration

**Root Cause**: Migration implemented without accompanying test strategy

**Solution**:

1. **Install testing dependencies**:
   ```bash
   cd apps/mobile
   npm install --save-dev @testing-library/react-native @testing-library/jest-native jest-expo
   ```

2. **Create jest.config.js**:
   ```javascript
   module.exports = {
     preset: 'jest-expo',
     setupFilesAfterEnv: ['@testing-library/jest-native/extend-expect'],
     testMatch: ['**/__tests__/**/*.(ts|tsx|js)', '**/*.(test|spec).(ts|tsx|js)'],
     collectCoverageFrom: [
       'src/**/*.{ts,tsx}',
       '!src/**/*.d.ts',
     ],
     coverageThreshold: {
       global: {
         branches: 70,
         functions: 70,
         lines: 70,
         statements: 70
       }
     }
   };
   ```

3. **Create core test files**:

   **src/components/__tests__/ScriptUpload.test.tsx**:
   ```typescript
   import React from 'react';
   import { render, fireEvent, waitFor } from '@testing-library/react-native';
   import { NativeBaseProvider } from 'native-base';
   import ScriptUpload from '../ScriptUpload';

   const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
     return <NativeBaseProvider>{children}</NativeBaseProvider>;
   };

   describe('ScriptUpload Component', () => {
     it('renders upload interface correctly', () => {
       const { getByText } = render(<ScriptUpload />, { wrapper: AllTheProviders });
       expect(getByText('Choose a script file')).toBeTruthy();
     });

     it('validates file types correctly', async () => {
       // Test PDF/TXT validation
       // Test file size limits (10MB)
       // Test error handling
     });

     it('handles upload progress display', async () => {
       // Test progress bar updates
       // Test status polling
     });
   });
   ```

   **src/services/__tests__/apiClient.test.ts**:
   ```typescript
   import { uploadScript, getScriptStatus } from '../apiClient';

   describe('API Client Cross-Platform', () => {
     it('handles multipart form data correctly', async () => {
       // Test file upload format
       // Test React Native Web compatibility
     });

     it('polls status correctly', async () => {
       // Test polling mechanism
       // Test timeout handling
     });
   });
   ```

4. **Add test scripts to package.json**:
   ```json
   {
     "scripts": {
       "test": "jest",
       "test:watch": "jest --watch",
       "test:coverage": "jest --coverage"
     }
   }
   ```

**Validation Criteria**:
- [ ] Test suite covers ScriptUpload component migration
- [ ] API client cross-platform compatibility tested
- [ ] Coverage threshold of 70% achieved
- [ ] All tests pass: `npm run test`

---

## Medium Priority Issues

### ARCH-001: Mixed Platform Components ⚠️ MEDIUM SEVERITY

**Problem**: HTML DOM elements used in React Native component (ScriptUpload.tsx:421-425)

**Solution**:

1. **Replace file input with expo-document-picker**:
   ```bash
   cd apps/mobile
   npm install expo-document-picker
   ```

2. **Update ScriptUpload component**:
   ```typescript
   import * as DocumentPicker from 'expo-document-picker';
   import { Platform } from 'react-native';

   const handleFilePicker = async () => {
     try {
       const result = await DocumentPicker.getDocumentAsync({
         type: ['application/pdf', 'text/plain'],
         copyToCacheDirectory: true,
         multiple: false
       });

       if (!result.canceled) {
         const file = result.assets[0];
         // Validate file size (10MB limit)
         if (file.size > 10 * 1024 * 1024) {
           throw new Error('File size exceeds 10MB limit');
         }
         handleFileSelection(file);
       }
     } catch (error) {
       setError('File selection failed');
     }
   };
   ```

3. **Add platform-specific drag-and-drop for web**:
   ```typescript
   const DragDropArea = Platform.select({
     web: () => (
       <Box
         onDrop={handleDrop}
         onDragOver={handleDragOver}
         // Web-specific drag and drop
       >
         {children}
       </Box>
     ),
     default: () => (
       <Pressable onPress={handleFilePicker}>
         {children}
       </Pressable>
     )
   });
   ```

**Validation Criteria**:
- [ ] No HTML DOM elements in React Native components
- [ ] File picker works on both web and mobile platforms
- [ ] Drag-and-drop preserved for web users

---

### NFR-001: Performance Validation Blocked ⚠️ MEDIUM SEVERITY

**Problem**: Cannot validate performance requirements due to build failures

**Solution** (After BUILD-001 is fixed):

1. **Create performance testing setup**:
   ```bash
   cd apps/mobile
   npm install --save-dev @expo/webpack-config webpack-bundle-analyzer
   ```

2. **Add bundle analysis script**:
   ```json
   {
     "scripts": {
       "analyze:web": "expo export --platform web --bundle-analyzer"
     }
   }
   ```

3. **Create performance benchmark test**:
   ```typescript
   // src/__tests__/performance.test.ts
   describe('Performance Benchmarks', () => {
     it('load time stays within 20% of baseline', async () => {
       // Measure app initialization time
       // Compare with Story 1.1 baseline
     });

     it('bundle size stays within acceptable limits', () => {
       // Analyze webpack bundle
       // Compare with Vite baseline
     });
   });
   ```

**Validation Criteria**:
- [ ] Load time within 20% of Story 1.1 baseline
- [ ] Bundle size analysis completed
- [ ] Memory usage profiled during file processing

---

## Security Remediation (IMMEDIATE ATTENTION)

### File Validation Security Gaps

**Current Issues**:
- Client-side only file validation
- Generic error messages may leak details
- No rate limiting documented

**Solutions**:

1. **Add server-side validation** (apps/api/src/routes/scripts.ts):
   ```typescript
   import multer from 'multer';
   import { fileTypeFromBuffer } from 'file-type';

   const upload = multer({
     limits: { fileSize: 10 * 1024 * 1024 }, // 10MB
     fileFilter: async (req, file, cb) => {
       // Server-side MIME type validation
       const allowedTypes = ['application/pdf', 'text/plain'];
       if (!allowedTypes.includes(file.mimetype)) {
         return cb(new Error('INVALID_FILE_TYPE'));
       }
       cb(null, true);
     }
   });

   // Add magic number validation
   router.post('/upload', upload.single('file'), async (req, res) => {
     const fileType = await fileTypeFromBuffer(req.file.buffer);
     if (!['pdf', 'txt'].includes(fileType?.ext)) {
       return res.status(400).json({ error: 'INVALID_FILE_FORMAT' });
     }
     // Continue processing...
   });
   ```

2. **Add rate limiting**:
   ```typescript
   import rateLimit from 'express-rate-limit';

   const uploadLimiter = rateLimit({
     windowMs: 15 * 60 * 1000, // 15 minutes
     max: 10, // 10 uploads per window
     message: 'RATE_LIMIT_EXCEEDED'
   });

   router.use('/upload', uploadLimiter);
   ```

3. **Sanitize error messages**:
   ```typescript
   const errorMessages = {
     'INVALID_FILE_TYPE': 'Please upload a PDF or text file',
     'FILE_TOO_LARGE': 'File size must be under 10MB',
     'RATE_LIMIT_EXCEEDED': 'Please wait before uploading again'
   };
   ```

---

## Implementation Sequence

### Phase 1: Critical Fixes (Day 1)
1. Fix BUILD-001: Update package.json and Metro config
2. Verify build process works end-to-end
3. Fix ARCH-001: Replace HTML inputs with expo-document-picker

### Phase 2: Testing Infrastructure (Day 2-3)
1. Set up Jest testing environment
2. Create ScriptUpload component tests
3. Add API client cross-platform tests
4. Achieve 70% coverage threshold

### Phase 3: Performance & Security (Day 4-5)
1. Implement server-side file validation
2. Add rate limiting to upload endpoints
3. Run performance benchmarks
4. Complete NFR validation

### Phase 4: Final Validation (Day 6)
1. Run complete test suite
2. Verify all acceptance criteria
3. Request QA re-review for gate status update

---

## Success Criteria for Gate Status Change

**FAIL → CONCERNS**:
- [ ] BUILD-001 resolved (build process works)
- [ ] TEST-001 resolved (70% test coverage achieved)

**CONCERNS → PASS**:
- [ ] ARCH-001 resolved (no mixed platform components)
- [ ] NFR-001 resolved (performance validated)
- [ ] Security concerns addressed
- [ ] All acceptance criteria verified

---

## Dev Agent Handoff Checklist

**Ready for Implementation**:
- [ ] All remediation steps documented
- [ ] Code examples provided for each fix
- [ ] Validation criteria clearly defined
- [ ] Implementation sequence prioritized
- [ ] Security requirements specified

**Post-Implementation**:
- [ ] Request QA re-review via `*review 1.2` command
- [ ] Update gate status based on new findings
- [ ] Document any additional issues discovered

---

*This remediation guide addresses all blocking issues identified in the quality gate. Following these steps should elevate the story from FAIL to PASS status.*

**Contact**: Quinn (Test Architect) for clarification on any remediation requirements.